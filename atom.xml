<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Naskete&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://naskete.github.io/"/>
  <updated>2024-07-21T03:41:32.329Z</updated>
  <id>https://naskete.github.io/</id>
  
  <author>
    <name>Naskete</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>github博客更换设备</title>
    <link href="https://naskete.github.io/2024/07/21/write/%E5%8D%9A%E5%AE%A2%E8%AE%BE%E5%A4%87%E8%BF%81%E7%A7%BB/"/>
    <id>https://naskete.github.io/2024/07/21/write/%E5%8D%9A%E5%AE%A2%E8%AE%BE%E5%A4%87%E8%BF%81%E7%A7%BB/</id>
    <published>2024-07-21T03:18:09.000Z</published>
    <updated>2024-07-21T03:41:32.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客设备迁移"><a href="#博客设备迁移" class="headerlink" title="博客设备迁移"></a>博客设备迁移</h1><p>断更多日，换了电脑设备后，打算迁移博客到新设备，然后更新学习记录</p><ul><li><p>安装git</p></li><li><p>安装nodejs</p></li><li><p>安装hexo</p></li><li><p>复制文件</p></li></ul><a id="more"></a><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>[git 安装](<a href="https://www.naskete.top/2020/08/11/essay/git%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener">git安装 | Naskete’s Blog</a>)</p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>官网建议通过fnm安装</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># installs fnm (Fast Node Manager)</span></span><br><span class="line">winget install Schniz.fnm</span><br><span class="line"></span><br><span class="line"><span class="comment"># download and install Node.js</span></span><br><span class="line">fnm use -<span class="literal">-install</span><span class="literal">-if</span><span class="literal">-missing</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># verifies the right Node.js version is in the environment</span></span><br><span class="line">node <span class="literal">-v</span> <span class="comment"># should print `v20.15.1`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># verifies the right npm version is in the environment</span></span><br><span class="line">npm <span class="literal">-v</span> <span class="comment"># should print `10.7.0`</span></span><br></pre></td></tr></table></figure><p>安装时<code>powershell</code>以管理员身份启动</p><p>执行<code>winget install Schniz.fn</code>后运行<code>fnm -v</code> 验证安装结果</p><p>执行<code>fnm use --install-if-missing 20</code> 报错，改用命令<code>fnm install 20</code></p><p>执行<code>node -v</code> 提示</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&lt;font color=<span class="string">'red'</span>&gt; node : 无法将“node”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次&lt;/font&gt;</span><br></pre></td></tr></table></figure><p><font color="red">node : 无法将“node”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确<br>，然后再试一次。</font></p><p>在命令行执行<code>fnm env --use-on-cd | Out-String | Invoke-Expression</code>即可</p><p>避免每次打开命令行都需要执行一次，找到<code>C:\Users\user\Documents\WindowsPowerShell</code>目录，<font color="red"> 记得把user替换为自己的登录用户名</font>，在目录下新建<code>profile.ps1</code>文件，讲<code>fnm env --use-on-cd | Out-String | Invoke-Expression</code>命令复制到改文件中即可</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>使用npm安装hexo </p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br></pre></td></tr></table></figure><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>最简单的办法就是把原来博客的文件夹整个复制到新设备中</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;博客设备迁移&quot;&gt;&lt;a href=&quot;#博客设备迁移&quot; class=&quot;headerlink&quot; title=&quot;博客设备迁移&quot;&gt;&lt;/a&gt;博客设备迁移&lt;/h1&gt;&lt;p&gt;断更多日，换了电脑设备后，打算迁移博客到新设备，然后更新学习记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装git&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装nodejs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装hexo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复制文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://Naskete.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-86.分隔链表</title>
    <link href="https://naskete.github.io/2023/08/15/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-86.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <id>https://naskete.github.io/2023/08/15/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-86.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</id>
    <published>2023-08-15T15:37:52.000Z</published>
    <updated>2023-08-17T15:37:08.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-86-分隔链表"><a href="#算法日记-LeetCode-86-分隔链表" class="headerlink" title="算法日记-LeetCode-86.分隔链表"></a>算法日记-LeetCode-86.分隔链表</h1><p>原题链接：<a href="https://leetcode.com/problems/partition-list/" target="_blank" rel="noopener">Partition List - LeetCode</a></p><a id="more"></a><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个链表list以及一个值x，将所有小于x的节点移到链表前面，不改变其原有的顺序</p><p>如：</p><p>x = 3</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A((1)) --&gt; B((4)) --&gt; C((3)) --&gt; D((2)) --&gt; E((2)) --&gt; F((3)) --&gt; G((5))</span><br><span class="line">H((1)) --&gt; I((2)) --&gt; J((2)) --&gt; K((4)) --&gt; L((3)) --&gt; M((3)) --&gt; N((5))</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个有点类似排序中的快排，给定一个标准值，大于标准值的往前，小于标准值的往后。在链表中没有索引，不能像数组中方便的交换两个值。</p><p>题目要求不能改变相对顺序，我们可以按照题目说的分隔，将大于等于x和小于x的分别存放到两个链表less和more中，最后将less的最后一个节点的next指向more的第一个节点即可。</p><p>注意：头节点是空节点，应该返回它的next，即less.next;</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode less = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode more = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode p = less, q = more;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &gt;= x) &#123;</span><br><span class="line">                q.next = head;</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p.next = head;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = more.next;</span><br><span class="line">        q.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> less.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-86-分隔链表&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-86-分隔链表&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-86.分隔链表&quot;&gt;&lt;/a&gt;算法日记-LeetCode-86.分隔链表&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.com/problems/partition-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Partition List - LeetCode&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="链表" scheme="https://Naskete.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-617.合并二叉树</title>
    <link href="https://naskete.github.io/2023/08/14/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://naskete.github.io/2023/08/14/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-08-14T15:24:56.000Z</published>
    <updated>2023-08-17T15:43:10.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-617-合并二叉树"><a href="#算法日记-LeetCode-617-合并二叉树" class="headerlink" title="算法日记-LeetCode-617.合并二叉树"></a>算法日记-LeetCode-617.合并二叉树</h1><p>原题链接：<a href="https://leetcode.cn/problems/merge-two-binary-trees/" target="_blank" rel="noopener">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p><a id="more"></a><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出两个二叉树，将两个二叉树重叠在一起</p><ul><li><p>如果都有值，新节点值为两值和</p></li><li><p>如果只有一个有值，新节点与其相等</p></li><li><p>都为空，新节点为空</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题目的意思，我们需要将两个二叉树的重合的节点值相加，如果不是两个都有，那么就哪棵树有节点就用哪个，都没有则节点为空</p><p>两棵树 tree1, tree2</p><ul><li><p>如果都有值 tree1.val + tree2.val</p></li><li><p>如果只有其中一个有 tree1.val 或者 tree2.val</p></li><li><p>都没有，节点为空</p></li></ul><p>二叉树都可以通过递归方法来操作，操作对象分为：根节点、左子树、右子树</p><p>按照这个思路，给出一个merge函数，先merge根节点，再merge左右子树</p><ul><li><p>merge根节点 ：判断tree1，tree2是否为空</p></li><li><p>merge左子树：merge tree1.left和tree2.left，走同样的merge逻辑</p></li><li><p>merge右子树：merge tree1.right 和 tree2.right</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 != <span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.val = root1.val + root2.val;</span><br><span class="line">            root.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">            root.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = root1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root1.val + root2.val);</span><br><span class="line">        root.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        root.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-617-合并二叉树&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-617-合并二叉树&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-617.合并二叉树&quot;&gt;&lt;/a&gt;算法日记-LeetCode-617.合并二叉树&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/merge-two-binary-trees/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="leetcode" scheme="https://Naskete.github.io/tags/leetcode/"/>
    
      <category term="二叉树" scheme="https://Naskete.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-53.最大子数组和</title>
    <link href="https://naskete.github.io/2023/08/09/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-53.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <id>https://naskete.github.io/2023/08/09/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-53.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</id>
    <published>2023-08-09T15:14:29.000Z</published>
    <updated>2023-08-17T15:59:25.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-53-最大子数组和"><a href="#算法日记-LeetCode-53-最大子数组和" class="headerlink" title="算法日记-LeetCode-53.最大子数组和"></a>算法日记-LeetCode-53.最大子数组和</h1><p>原题链接：<a href="https://leetcode.cn/problems/maximum-subarray/description/" target="_blank" rel="noopener">53. 最大子数组和 - 力扣（LeetCode）</a></p><a id="more"></a><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>明确定义：</p><p>我们可以通过dp数组记录，dp[i]表示<em>以下标i结尾的「连续子数组的最大和」</em>，记为f(i)，那么要求到i + 1结尾的<em>连续子数组的最大和</em>，只要比较nums[i + 1]，f(i) + nums[i+ 1]，取他们中的最大值即可。 </p><p>状态转移方程：dp[i + 1] = Math.max(dp[i] + num[i + 1], num[i + 1])  </p><p>最后，取整个dp数组的最大值，即为所求的结果</p><hr><p>简化写法</p><p>由于f(i)的值只与f(i - 1)有关，所以可以用一个值来记录，表示f(i)和f(i - 1)的关系</p><p>f(i) = f(i - 1) + num[i]，可以通过变量的形式，将这一个关系维持到遍历结束 </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + num, num);</span><br><span class="line">            max = Math.max(pre, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-53-最大子数组和&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-53-最大子数组和&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-53.最大子数组和&quot;&gt;&lt;/a&gt;算法日记-LeetCode-53.最大子数组和&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/maximum-subarray/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;53. 最大子数组和 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="leetcode" scheme="https://Naskete.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-344.反转字符串</title>
    <link href="https://naskete.github.io/2023/08/07/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://naskete.github.io/2023/08/07/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-08-07T15:26:35.000Z</published>
    <updated>2023-08-07T15:32:53.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-344-反转字符串"><a href="#算法日记-LeetCode-344-反转字符串" class="headerlink" title="算法日记-LeetCode-344.反转字符串"></a>算法日记-LeetCode-344.反转字符串</h1><p>原题链接：<a href="https://leetcode.cn/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串 - 力扣（LeetCode）</a></p><a id="more"></a><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个字符数组，在原数组中将该数组反转</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><a href="https://www.naskete.top/2023/02/19/algorithm/java%E4%B8%AD%E7%9A%84%E5%8F%8D%E8%BD%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">JAVA中的反转操作（一） | Naskete’s Blog</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-344-反转字符串&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-344-反转字符串&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-344.反转字符串&quot;&gt;&lt;/a&gt;算法日记-LeetCode-344.反转字符串&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/reverse-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;344. 反转字符串 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="leetcode" scheme="https://Naskete.github.io/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://Naskete.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-24.两两交换链表中的节点</title>
    <link href="https://naskete.github.io/2023/08/06/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://naskete.github.io/2023/08/06/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2023-08-06T14:16:45.000Z</published>
    <updated>2023-08-17T16:14:25.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-24-两两交换链表中的节点"><a href="#算法日记-LeetCode-24-两两交换链表中的节点" class="headerlink" title="算法日记-LeetCode-24.两两交换链表中的节点"></a>算法日记-LeetCode-24.两两交换链表中的节点</h1><p>原题链接：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><a id="more"></a><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个链表，对链表的每两个节点做一次反转</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-24-两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-24-两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-24.两两交换链表中的节点&quot;&gt;&lt;/a&gt;算法日记-LeetCode-24.两两交换链表中的节点&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/swap-nodes-in-pairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;24. 两两交换链表中的节点 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-4-寻找两个正序数组的中位数</title>
    <link href="https://naskete.github.io/2023/07/26/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://naskete.github.io/2023/07/26/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2023-07-26T14:01:28.000Z</published>
    <updated>2023-08-06T15:29:10.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-4-寻找两个正序数组的中位数"><a href="#算法日记-LeetCode-4-寻找两个正序数组的中位数" class="headerlink" title="算法日记-LeetCode-4.寻找两个正序数组的中位数"></a>算法日记-LeetCode-4.寻找两个正序数组的中位数</h1><p>原题链接：<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数 - 力扣（LeetCode）</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><a id="more"></a><p>给定两个有序的数组num1， num2，请你找出并返回这两个正序数组的 <strong>中位数</strong></p><p>即数组中点的值，如果长度和为偶数则求平均值</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><p>归并排序</p><pre><code>借助归并排序的思想，合并两个有序数组，得到一个新的数组，求该新数组中间值即可</code></pre></li><li><p>二分查找</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>归并</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length, n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> mid = (m + n) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            help[idx++] = nums1[i] &lt; nums2[j] ? nums1[i++] : nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">            help[idx++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">            help[idx++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (m + n) % <span class="number">2</span> != <span class="number">0</span> ? help[mid] * <span class="number">1.0</span> : (help[mid - <span class="number">1</span>] + help[mid]) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>二分查找</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-4-寻找两个正序数组的中位数&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-4-寻找两个正序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-4.寻找两个正序数组的中位数&quot;&gt;&lt;/a&gt;算法日记-LeetCode-4.寻找两个正序数组的中位数&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/median-of-two-sorted-arrays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;4. 寻找两个正序数组的中位数 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法日记-771-宝石与石头</title>
    <link href="https://naskete.github.io/2023/07/24/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-771.%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/"/>
    <id>https://naskete.github.io/2023/07/24/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-771.%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/</id>
    <published>2023-07-24T15:58:52.000Z</published>
    <updated>2023-08-07T15:36:14.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-771-宝石与石头"><a href="#算法日记-LeetCode-771-宝石与石头" class="headerlink" title="算法日记-LeetCode-771.宝石与石头"></a>算法日记-LeetCode-771.宝石与石头</h1><p>原题链接：<a href="https://leetcode.cn/problems/jewels-and-stones/" target="_blank" rel="noopener">771. 宝石与石头 - 力扣（LeetCode）</a></p><a id="more"></a><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给的一个字符串jewels，每个字符表示一种宝石，另外一个字符串stones表示石头，求stones中有多少宝石</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： jewels&#x3D;&quot;aA&quot;, stones&#x3D;&quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>通过Set存储jewels中的字符，然后看stones中有多少字符在集合中存在</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String jewels, String stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = jewels.length(), n = stones.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            set.add(jewels.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(stones.charAt(i))) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-771-宝石与石头&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-771-宝石与石头&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-771.宝石与石头&quot;&gt;&lt;/a&gt;算法日记-LeetCode-771.宝石与石头&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/jewels-and-stones/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;771. 宝石与石头 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="leetcode" scheme="https://Naskete.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-415-字符串相加</title>
    <link href="https://naskete.github.io/2023/07/17/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-415.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"/>
    <id>https://naskete.github.io/2023/07/17/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-415.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</id>
    <published>2023-07-17T13:31:00.000Z</published>
    <updated>2023-08-07T15:39:43.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-415-字符串相加"><a href="#算法日记-LeetCode-415-字符串相加" class="headerlink" title="算法日记-LeetCode-415.字符串相加"></a>算法日记-LeetCode-415.字符串相加</h1><p>原题链接：<a href="https://leetcode.cn/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加 - 力扣（LeetCode）</a></p><a id="more"></a><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定两个只包含数字的字符串，求出两个字符串的和，以字符串形式返回</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：num1 = <span class="string">"11"</span>, num2 = <span class="string">"123"</span></span><br><span class="line">输出：<span class="string">"134"</span></span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>模拟相加过程，从右往左遍历，依次相加</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            ans.append(result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.reverse();</span><br><span class="line">        <span class="keyword">return</span> ans.toString();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-415-字符串相加&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-415-字符串相加&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-415.字符串相加&quot;&gt;&lt;/a&gt;算法日记-LeetCode-415.字符串相加&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/add-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;415. 字符串相加 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-94.二叉树的中序遍历</title>
    <link href="https://naskete.github.io/2023/07/16/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://naskete.github.io/2023/07/16/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2023-07-16T14:26:20.000Z</published>
    <updated>2023-08-07T15:34:29.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-94-二叉树的中序遍历"><a href="#算法日记-LeetCode-94-二叉树的中序遍历" class="headerlink" title="算法日记-LeetCode-94.二叉树的中序遍历"></a>算法日记-LeetCode-94.二叉树的中序遍历</h1><p>原题链接：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><p>迭代</p></li><li><p>递归</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>迭代</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty() || node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>递归</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        traversal(root, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traversal(root.left, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        traversal(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-94-二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-94-二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-94.二叉树的中序遍历&quot;&gt;&lt;/a&gt;算法日记-LeetCode-94.二叉树的中序遍历&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/binary-tree-inorder-traversal/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;94. 二叉树的中序遍历 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="leetcode" scheme="https://Naskete.github.io/tags/leetcode/"/>
    
      <category term="二叉树" scheme="https://Naskete.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-18.四数之和</title>
    <link href="https://naskete.github.io/2023/07/15/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-18.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://naskete.github.io/2023/07/15/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-18.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2023-07-15T15:30:45.000Z</published>
    <updated>2023-07-16T14:17:00.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-18-四数之和"><a href="#算法日记-LeetCode-18-四数之和" class="headerlink" title="算法日记-LeetCode-18.四数之和"></a>算法日记-LeetCode-18.四数之和</h1><p>原题链接：<a href="https://leetcode.cn/problems/4sum/" target="_blank" rel="noopener">18. 四数之和 - 力扣（LeetCode）</a></p><a id="more"></a><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个无序数组nums，以及目标值target，请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code></p><ul><li><p>0 &lt;= a &lt; b &lt; c&lt; d &lt; n</p></li><li><p>nums[a] + nums[b] + nums[c] + nums[d] = target</p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>最直接的解决方法就是通过四重循环，但是四重循环的时间复杂度高，会超时</p><h4 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序 + 双指针"></a>排序 + 双指针</h4><p>四数之和与三数之和类型，可以通过，排序+双指针的方式，减少一重循环</p><p>对数组进行排序，然后通过两重循环确定nums[a]，nums[b]</p><p>随后借助双指针left和right确定nums[c]和nums[d]</p><p>sum = nums[left] + nums[right]</p><ul><li><p>nums[a] + nums[b] + sum == target 满足条件</p></li><li><p>nums[a] + nums[b] + sum &gt; target 右指针左移</p></li><li><p>nums[a] + nums[b] + sum &lt; target 左指针右移</p></li></ul><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; n - <span class="number">3</span>; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = a + <span class="number">1</span>; b &lt; n - <span class="number">2</span>; b ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b &gt; a + <span class="number">1</span> &amp;&amp; nums[b] == nums[b - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> left = b + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">long</span> sum = nums[left] + nums[right]; <span class="comment">// long 型防止溢出</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[a] + nums[b] == target - sum) &#123;</span><br><span class="line">                        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[a], nums[b], nums[left], nums[right]));</span><br><span class="line">                        list.add(ans);</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[a] + nums[b] &gt; target - sum) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[a] + nums[b] &lt; target - sum)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0ms-范例"><a href="#0ms-范例" class="headerlink" title="0ms 范例"></a>0ms 范例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractList&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">                init();</span><br><span class="line">                <span class="keyword">return</span> list.get(index);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                init();</span><br><span class="line">                <span class="keyword">return</span> list.size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> Set&lt;List&lt;Integer&gt;&gt; listSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                Arrays.sort(nums);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt; i + <span class="number">2</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> l = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> r = j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="keyword">long</span> m = (<span class="keyword">long</span>) nums[i] + (<span class="keyword">long</span>) nums[j] + (<span class="keyword">long</span>) nums[l] + (<span class="keyword">long</span>) nums[r];</span><br><span class="line">                    <span class="keyword">if</span> (m ==  target) &#123;</span><br><span class="line">                        listSet.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));</span><br><span class="line">                        l++;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &gt; target) &#123;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                list = <span class="keyword">new</span> ArrayList&lt;&gt;(listSet);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-18-四数之和&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-18-四数之和&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-18.四数之和&quot;&gt;&lt;/a&gt;算法日记-LeetCode-18.四数之和&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/4sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;18. 四数之和 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="leetcode" scheme="https://Naskete.github.io/tags/leetcode/"/>
    
      <category term="双指针" scheme="https://Naskete.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-931-下降路径最小和</title>
    <link href="https://naskete.github.io/2023/07/13/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-931.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C/"/>
    <id>https://naskete.github.io/2023/07/13/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-931.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C/</id>
    <published>2023-07-13T15:53:07.000Z</published>
    <updated>2023-07-16T14:17:11.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-931-下降路径最小和"><a href="#算法日记-LeetCode-931-下降路径最小和" class="headerlink" title="算法日记-LeetCode-931.下降路径最小和"></a>算法日记-LeetCode-931.下降路径最小和</h1><p>原题链接：<a href="https://leetcode.cn/problems/minimum-falling-path-sum/" target="_blank" rel="noopener">931. 下降路径最小和 - 力扣（LeetCode）</a></p><a id="more"></a><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个n x n的矩阵 matrix，求出通过 matrix 的<strong>下降路径</strong> 的<strong>最小和</strong> 。</p><p><strong>下降路径</strong>：从第一行中的任意元素开始往下，往下的过程中可以选择左下，正下，右下方的元素，即(i, j) 可以选择(i + 1, j - 1)，(i + 1, j)，(i + 1, j + 1)作为下一个元素。</p><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：<span class="number">13</span></span><br></pre></td></tr></table></figure><img src="/2023/07/13/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-931.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C/example.png" class title="loading-ag-1028"><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题是dp问题，也就是动态规划类的问题，我们需要找出状态转移方程。</p><p>根据题意，我们知道，我们从上往下走，可以从当前行元素，选择下一行中的特定三个值。</p><img src="/2023/07/13/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-931.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C/model.png" class title="loading-ag-1030"><p>通过dp数组记录答案，dp[i][j]表示的是，从第一行到(i,j)位置的下降路径最小和，即dp数组中的每一个元素都是对应位置所求的答案。最后我们只要在最后一行，即dp[n - 1]中，找到最小值即可。</p><p>dp[i][j]的值，是martix[i][j]与上一行中三个相关位置的值，依赖关系如下：</p><img src="/2023/07/13/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-931.%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C/trans.png" class title="loading-ag-1032"><p>所以可以得到转移方程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = martix[i][j] + min(dp[i - <span class="number">1</span>][j-<span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j + <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>即矩阵中的当前值，和dp数组中，可能到达给位置的最小值的和</p><p>需要注意边界，dp[i][0]，dp[i][n - 1]，这两个位置一个在最左边，一个在最右边，只与上一行中的两个值有关。</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] + Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] + Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] + Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            min = Math.min(min, dp[n - <span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int min = Arrays.stream(dp[n - 1]).min().getAsInt();</span></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0ms范例"><a href="#0ms范例" class="headerlink" title="0ms范例"></a>0ms范例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        System.arraycopy(matrix[<span class="number">0</span>], <span class="number">0</span>, dp, <span class="number">0</span>, n);</span><br><span class="line">        dp = dfs(matrix, dp, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            res = Math.min(res, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] dfs(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[] dp, <span class="keyword">int</span> depth, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nextDp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = dp[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) cur = Math.min(cur, dp[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) cur = Math.min(cur, dp[i + <span class="number">1</span>]);</span><br><span class="line">            nextDp[i] = cur + matrix[depth][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(matrix, nextDp, depth + <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-931-下降路径最小和&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-931-下降路径最小和&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-931.下降路径最小和&quot;&gt;&lt;/a&gt;算法日记-LeetCode-931.下降路径最小和&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/minimum-falling-path-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;931. 下降路径最小和 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="leetcode" scheme="https://Naskete.github.io/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://Naskete.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-2544-交替数字和</title>
    <link href="https://naskete.github.io/2023/07/12/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-2544.%E4%BA%A4%E6%9B%BF%E6%95%B0%E5%AD%97%E5%92%8C/"/>
    <id>https://naskete.github.io/2023/07/12/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-2544.%E4%BA%A4%E6%9B%BF%E6%95%B0%E5%AD%97%E5%92%8C/</id>
    <published>2023-07-12T14:13:46.000Z</published>
    <updated>2023-08-17T16:21:00.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-2544-交替数字和"><a href="#LeetCode-2544-交替数字和" class="headerlink" title="LeetCode-2544.交替数字和"></a>LeetCode-2544.交替数字和</h1><p>原题链接：<a href="https://leetcode.cn/problems/alternating-digit-sum/" target="_blank" rel="noopener">2544. 交替数字和 - 力扣（LeetCode）</a></p><a id="more"></a><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数字，奇数位的数字取正值，偶数位的数字取负值，求最后和的值。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">524</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">说明：<span class="number">5</span> + （-<span class="number">2</span>） + <span class="number">4</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过标志位flag来控制符号，flag初始值为1，用于控制数字每一位的符号。</p><p>获取每一位的数值，可以通过将数字转换为字符串，然后遍历；或者取余，借助栈存储每一位的值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">alternateDigitSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String num = String.valueOf(n);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = num.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            sum += (num.charAt(i) - <span class="number">48</span>) * flag;</span><br><span class="line">            flag = -flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-2544-交替数字和&quot;&gt;&lt;a href=&quot;#LeetCode-2544-交替数字和&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-2544.交替数字和&quot;&gt;&lt;/a&gt;LeetCode-2544.交替数字和&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/alternating-digit-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2544. 交替数字和 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="leetcode" scheme="https://Naskete.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-1911-最大子序列交替和</title>
    <link href="https://naskete.github.io/2023/07/11/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-1911.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E4%BA%A4%E6%9B%BF%E5%92%8C/"/>
    <id>https://naskete.github.io/2023/07/11/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-1911.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E4%BA%A4%E6%9B%BF%E5%92%8C/</id>
    <published>2023-07-11T15:05:00.000Z</published>
    <updated>2023-07-16T14:16:36.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-1911-最大子序列交替和"><a href="#算法日记-LeetCode-1911-最大子序列交替和" class="headerlink" title="算法日记-LeetCode-1911.最大子序列交替和"></a>算法日记-LeetCode-1911.最大子序列交替和</h1><p>原题链接：<a href="https://leetcode.cn/problems/maximum-alternating-subsequence-sum/" target="_blank" rel="noopener">1911. 最大子序列交替和 - 力扣（LeetCode）</a></p><a id="more"></a><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数组，定义奇数位取正值，偶数位取负值，得到的和为交替和，求出在该数组，所有子序列中，最大的交替和。</p><p>子序列：不改变相对顺序删除数组中0~n-1个值，n为数组长度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：最优子序列为 [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>] ，交替和为 (<span class="number">4</span> + <span class="number">5</span>) - <span class="number">2</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h4><p>按最粗暴的方式，求出数组的所有子序列，再得到每个子序列的交替和，然后最大的值即为解。</p><p>求子序列和的方式，</p><p>子序列就是从数组中删除0个或者多个值，且其相对顺序不变</p><p>比如:</p><p>[1, 2, 3] 的子序列</p><ul><li><p>[1, 2, 3]</p></li><li><p>[1, 2]</p></li><li><p>[1, 3]</p></li><li><p>[2, 3]</p></li><li><p>[1]</p></li><li><p>[2]</p></li><li><p>[3]</p></li></ul><p>求子序列的思路</p><p>遍历数组，对数组中的每一个值，可以选择保留或者删除，最后得到的所有可能的结果就是所有的子序列。</p><p>编写递归函数求解，结束条件为，遍历结束</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nums 给定的数组</span></span><br><span class="line"><span class="comment"> * cur 遍历过程中的当前索引</span></span><br><span class="line"><span class="comment"> * len 数组长度，递归终止条件</span></span><br><span class="line"><span class="comment"> * val 到cur位置得到的交替和结果</span></span><br><span class="line"><span class="comment"> * flag 正负1，用于控制交替和的符号</span></span><br><span class="line"><span class="comment"> * value 结果数组，用于保存最后的交替和结果</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAlternatingSubSequenceSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> cur, <span class="keyword">int</span> len, <span class="keyword">int</span> val, <span class="keyword">int</span> flag, List&lt;Integer&gt; value)</span></span></span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="暴力解——超出内存限制"><a href="#暴力解——超出内存限制" class="headerlink" title="暴力解——超出内存限制"></a>暴力解——超出内存限制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxAlternatingSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        getAlternatingSubSequenceSum(nums, <span class="number">0</span>, n, <span class="number">0</span>, <span class="number">1</span>, list);</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : list) &#123;</span><br><span class="line">            max = Math.max(v, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有子序列的交替和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAlternatingSubSequenceSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> cur, <span class="keyword">int</span> len, <span class="keyword">int</span> val, <span class="keyword">int</span> flag, List&lt;Integer&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == len) &#123;</span><br><span class="line">            value.add(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// flag控制符号</span></span><br><span class="line">        <span class="keyword">int</span> add =val + flag * nums[cur]; <span class="comment">// 当前元素保留</span></span><br><span class="line">        getAlternatingSubSequenceSum(nums, cur + <span class="number">1</span>, len, add, -flag, value);</span><br><span class="line">        <span class="keyword">int</span> next = val; <span class="comment">// 当前元素不保留</span></span><br><span class="line">        getAlternatingSubSequenceSum(nums, cur + <span class="number">1</span>, len, next, flag, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxAlternatingSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> even = nums[<span class="number">0</span>], odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            even = Math.max(even, odd + nums[i]);</span><br><span class="line">            odd = Math.max(odd, even - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> even;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解：</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-1911-最大子序列交替和&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-1911-最大子序列交替和&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-1911.最大子序列交替和&quot;&gt;&lt;/a&gt;算法日记-LeetCode-1911.最大子序列交替和&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/maximum-alternating-subsequence-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1911. 最大子序列交替和 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="leetcode" scheme="https://Naskete.github.io/tags/leetcode/"/>
    
      <category term="子序列" scheme="https://Naskete.github.io/tags/%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
      <category term="动态规划" scheme="https://Naskete.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-111-二叉树的最小深度</title>
    <link href="https://naskete.github.io/2023/07/10/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <id>https://naskete.github.io/2023/07/10/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</id>
    <published>2023-07-10T15:15:57.000Z</published>
    <updated>2023-07-16T14:16:45.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-111-二叉树的最小深度"><a href="#算法日记-LeetCode-111-二叉树的最小深度" class="headerlink" title="算法日记-LeetCode-111.二叉树的最小深度"></a>算法日记-LeetCode-111.二叉树的最小深度</h1><p>原题链接：<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度 - 力扣（LeetCode）</a></p><a id="more"></a><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一颗二叉树，要求给出根节点到最近的叶子节点的路径所包含的节点个数。</p><img title src="/2023/07/10/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/example.png" alt="loading-ag-1074" data-align="center"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">说明：<span class="number">1</span> -&gt; <span class="number">2</span> 共两个节点</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>叶子节点，其左右子树都为null；我们可以通过判断左右子树来确定叶子节点，然后就需要计算出根节点到当前叶子节点的路径中包含了多少节点。</p><p>如何获取根节点到叶子节点的路径所包含的节点个数？</p><p>我们可以这样计算，将二叉树简化为一个根节点和左右两个子树。</p><p>根节点到其左子节点的距离就是1（根节点） + 左子节点的对应值</p><p>即我们可以不断的从子树获取所需的信息，然后进行相关的计算。</p><p>例如：</p><img src="/2023/07/10/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/des.png" class><p>这里我们要得到节点1到叶子节点4包含的节点数</p><ul><li><p>从节点4开始，往左右子节点取值，左右子节点为空，返回0，算上本身，所以是1；</p></li><li><p>然后到节点3，节点3到节点4，节点3自己算一个，所以是1，然后获取节点4的对应值也是1，所以节点3到节点4的距离，可以记录为1（节点3自己） + 1（节点4的值） = 2</p></li><li><p>然后节点1到节点4经过右子节点3，节点1本身加上节点3到节点4的距离2，最后得到节点1到节点4的距离 1 + 2 = 3</p></li></ul><p>故按照这个思路，我们可以求得根节点到每一个叶子节点的值，最后取其中最小的即为符合题意的解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>递归解法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="keyword">null</span> &amp;&amp; root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.min(minDepth(root.left), minDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-111-二叉树的最小深度&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-111-二叉树的最小深度&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-111.二叉树的最小深度&quot;&gt;&lt;/a&gt;算法日记-LeetCode-111.二叉树的最小深度&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/minimum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;111. 二叉树的最小深度 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="leetcode" scheme="https://Naskete.github.io/tags/leetcode/"/>
    
      <category term="二叉树" scheme="https://Naskete.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://Naskete.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-15-三数之和</title>
    <link href="https://naskete.github.io/2023/07/09/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8CII/"/>
    <id>https://naskete.github.io/2023/07/09/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8CII/</id>
    <published>2023-07-09T14:07:20.000Z</published>
    <updated>2023-07-16T14:16:50.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-15-三数之和"><a href="#算法日记-LeetCode-15-三数之和" class="headerlink" title="算法日记-LeetCode-15-三数之和"></a>算法日记-LeetCode-15-三数之和</h1><p>原题链接：<a href="https://leetcode.cn/problems/3sum/" target="_blank" rel="noopener">15. 三数之和 - 力扣（LeetCode）</a> </p><a id="more"></a><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个无序数组，数组长度[3, 3000]，求出所有满足nums[i] + nums[j] + nums[k] = 0的三元组，且i != j, j != k。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">4</span>]</span><br><span class="line">输出：[[-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>],[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">解释：</span><br><span class="line">nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>] = (-<span class="number">1</span>) + <span class="number">0</span> + <span class="number">1</span> = <span class="number">0</span> 。</span><br><span class="line">nums[<span class="number">1</span>] + nums[<span class="number">2</span>] + nums[<span class="number">4</span>] = <span class="number">0</span> + <span class="number">1</span> + (-<span class="number">1</span>) = <span class="number">0</span> 。</span><br><span class="line">nums[<span class="number">0</span>] + nums[<span class="number">3</span>] + nums[<span class="number">4</span>] = (-<span class="number">1</span>) + <span class="number">2</span> + (-<span class="number">1</span>) = <span class="number">0</span> 。</span><br><span class="line">不同的三元组是 [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>] 和 [-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>通过三重循环遍历数组，找到满足条件的值，三重循环容易超时</p><h4 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序 + 双指针"></a>排序 + 双指针</h4><p>首先对数组进行排序，排序后可采用双指针的方式缩小范围得到目标值。</p><p>对排序后的数组进行遍历，如果nums[idx] &gt; 0，则之后肯定不存在满足条件的值，此时可以直接返回结果，且题目要求不重复，故需要对重复的元素进行跳过。</p><p>从i开始，令left = idx + 1, rigth = n - 1，则存在以下三种情况：</p><ul><li><p>nums[idx] + nums[left] + nums[right] = 0 ： 即为目标解</p></li><li><p>nums[idx] + nums[left] + nums[right] &gt; 0 : nums[right] 过大， right 左移；</p></li><li><p>nums[idx] + nums[left] + nums[right] &lt; 0 : nums[left] 过小， left 右移</p></li></ul><p>直到left与right相遇。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (idx &gt; <span class="number">0</span> &amp;&amp; idx &lt; n &amp;&amp; nums[idx] == nums[idx - <span class="number">1</span>]) &#123;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = idx + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[idx] + nums[left] + nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    ans.add(nums[idx]);</span><br><span class="line">                    ans.add(nums[left]);</span><br><span class="line">                    ans.add(nums[right]);</span><br><span class="line">                    list.add(ans);</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[idx] + nums[left] + nums[right] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[idx] + nums[left] + nums[right] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-15-三数之和&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-15-三数之和&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-15-三数之和&quot;&gt;&lt;/a&gt;算法日记-LeetCode-15-三数之和&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/3sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;15. 三数之和 - 力扣（LeetCode）&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="leetcode" scheme="https://Naskete.github.io/tags/leetcode/"/>
    
      <category term="双指针" scheme="https://Naskete.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>算法日记-LeetCode-167.两数之和</title>
    <link href="https://naskete.github.io/2023/07/08/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII/"/>
    <id>https://naskete.github.io/2023/07/08/algorithm/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0-LeetCode-167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII/</id>
    <published>2023-07-08T10:27:29.000Z</published>
    <updated>2023-07-16T14:16:56.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法日记-LeetCode-167-两数之和"><a href="#算法日记-LeetCode-167-两数之和" class="headerlink" title="算法日记-LeetCode-167.两数之和"></a>算法日记-LeetCode-167.两数之和</h1><p>原题链接：<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）</a>  </p><a id="more"></a><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个有序非递减数组numbers以及一个目标值target，要求求出数组中和为target的两个数字的下标</p><p>每个输入 <strong>只对应唯一的答案</strong> ，而且<strong>不可以</strong> 重复使用相同的元素</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：numbers = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：<span class="number">2</span> 与 <span class="number">7</span> 之和等于目标数 <span class="number">9</span> 。因此 index1 = <span class="number">1</span>, index2 = <span class="number">2</span> 。返回 [<span class="number">1</span>, <span class="number">2</span>] 。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>给出数组为有序数组，且非递减，即numbers[i] &lt;= numbers[i+ 1]，且题目中给出了答案唯一的限制</p><p>采用双指针的方法，left和right分别指向数组的左右两端，得到的和sum 与target进行比较，如果sum &gt; target，则右侧指针向左移动；反之左侧指针向右移动。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法日记-LeetCode-167-两数之和&quot;&gt;&lt;a href=&quot;#算法日记-LeetCode-167-两数之和&quot; class=&quot;headerlink&quot; title=&quot;算法日记-LeetCode-167.两数之和&quot;&gt;&lt;/a&gt;算法日记-LeetCode-167.两数之和&lt;/h1&gt;&lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="leetcode" scheme="https://Naskete.github.io/tags/leetcode/"/>
    
      <category term="双指针" scheme="https://Naskete.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的反转操作（二）</title>
    <link href="https://naskete.github.io/2023/03/08/algorithm/java%E4%B8%AD%E7%9A%84%E5%8F%8D%E8%BD%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://naskete.github.io/2023/03/08/algorithm/java%E4%B8%AD%E7%9A%84%E5%8F%8D%E8%BD%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2023-03-08T14:28:00.000Z</published>
    <updated>2023-07-08T11:16:18.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA中的反转操作（二）-——-反转链表"><a href="#JAVA中的反转操作（二）-——-反转链表" class="headerlink" title="JAVA中的反转操作（二） —— 反转链表"></a>JAVA中的反转操作（二） —— 反转链表</h1><h2 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h2><p>对于链表的节点定义如下，这里只给出单链表的结构</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, ListNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转过程"><a href="#反转过程" class="headerlink" title="反转过程"></a>反转过程</h2><p>效果如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A((0)) ---&gt; B((1)) ---&gt; C((2)) ---&gt; D((3)) ---&gt; E((4))</span><br><span class="line">F((4)) ---&gt; G((3)) ---&gt; H((2)) ---&gt; I((1)) ---&gt; J((0))</span><br></pre></td></tr></table></figure><p>具体实现：</p><p>分别用pre, cur，next指针进行定位，pre先指向null, cur指向当前head，next指向null，标记cur的下一个节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>, next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA中的反转操作（二）-——-反转链表&quot;&gt;&lt;a href=&quot;#JAVA中的反转操作（二）-——-反转链表&quot; class=&quot;headerlink&quot; title=&quot;JAVA中的反转操作（二） —— 反转链表&quot;&gt;&lt;/a&gt;JAVA中的反转操作（二） —— 反转链表&lt;/h1&gt;&lt;h2 id=&quot;节点定义&quot;&gt;&lt;a href=&quot;#节点定义&quot; class=&quot;headerlink&quot; title=&quot;节点定义&quot;&gt;&lt;/a&gt;节点定义&lt;/h2&gt;&lt;p&gt;对于链表的节点定义如下，这里只给出单链表的结构&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://Naskete.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="链表反转" scheme="https://Naskete.github.io/tags/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>算法学习笔记-单调栈</title>
    <link href="https://naskete.github.io/2023/02/27/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://naskete.github.io/2023/02/27/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2023-02-27T13:32:28.000Z</published>
    <updated>2023-07-29T16:22:01.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法学习笔记-单调栈"><a href="#算法学习笔记-单调栈" class="headerlink" title="算法学习笔记-单调栈"></a>算法学习笔记-单调栈</h1><p>今天碰到一道题，印象中感觉可以用单调栈做的，但是发现自己一下子想不起来了，所以还是再看看，加深一下印象</p><a id="more"></a><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调栈可以分为以下两种</p><ul><li><p>单调增栈</p></li><li><p>单调减栈</p></li></ul><p>单调栈每次操作都保证栈中的值单调递增或递减</p><p>单调栈可以解决的问题：</p><p>每一个元素左边比该元素大/小且<strong>最近</strong>的元素以及右边比该元素大/小且<strong>最近</strong>的元素</p><p>例如：</p><p>给定一个数组，假设我要找到每个数右边比它小的第一个数</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span></span><br></pre></td></tr></table></figure><p>则单调栈的过程为：</p><ol><li><p>push 7 </p></li><li><p>1 &lt; 7 故 pop 7 , push 1，得到7右边第一个比它小的值1 </p></li><li><p>5 &gt; 1 故 push 5</p></li><li><p>3 &lt; 5 故 pop 5, push 3， 得到5右边第一个比它小的值3</p></li><li><p>6 &gt; 3 故 push 6</p></li><li><p>4 &lt; 6 故 pop 6, push 4，得到6右边第一个比它小的值4</p></li></ol><p>栈内元素从栈顶到栈底分别为 ： 4 3 1 </p><h3 id="LeetCode-题"><a href="#LeetCode-题" class="headerlink" title="LeetCode 题"></a>LeetCode 题</h3><h4 id="496-下一个更大元素-I-力扣（LeetCode）"><a href="#496-下一个更大元素-I-力扣（LeetCode）" class="headerlink" title="496. 下一个更大元素 I - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/next-greater-element-i" target="_blank" rel="noopener">496. 下一个更大元素 I - 力扣（LeetCode）</a></h4><p>题目大意：</p><p>给定两个数组 nums1,nums2. nums2中的元素包含nums1的元素，但是顺序不同</p><p>找出nums2中<strong>各元素</strong>的<strong>右边第一个</strong>比它<strong>大</strong>的值，没有就取-1</p><p>按nums1中的顺序返回对应的值</p><p>输入：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>] nums2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>return : </p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">-1</span>]</span><br><span class="line">解释： nums2 中 <span class="number">1</span> 右边第一个比它大的是<span class="number">3</span>,<span class="number">3</span>右边第一个比它大的是<span class="number">4</span>，<span class="number">4</span>之后没有比它大的，所以是<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums1.length;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历，借助单调栈统计</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peek()) &#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                map.put(top, nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums2[i], -<span class="number">1</span>); <span class="comment">// 暂存 -1 找到后会出栈</span></span><br><span class="line">            stack.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            res[idx++] = map.get(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方给出的题解为从后往前遍历，可以省去处理栈的部分，因为栈是先进后出的结构</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nums2.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = nums2[i];</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; num &gt;= stack.peek()) &#123;</span><br><span class="line">         stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(num, stack.isEmpty() ? -<span class="number">1</span> : stack.peek());</span><br><span class="line">    stack.push(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="503-下一个更大元素-II-力扣（LeetCode）"><a href="#503-下一个更大元素-II-力扣（LeetCode）" class="headerlink" title="503. 下一个更大元素 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. 下一个更大元素 II - 力扣（LeetCode）</a></h4><p>题目大意：</p><p>给定一个环形数组，找出每一个元素后比它大的第一个数</p><p>输入：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>return:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>因为添加了一个环形条件，就相当于既包括后面，又包括前面</p><p>我们可以在处理时将数组复制后添加在原数组后面</p><p>具体处理为：取数组长度的两倍，然后索引值取 nums[i % len]，为了方便存储结果，我们在栈中存储索引值</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i%len] &gt; nums[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = stack.pop();</span><br><span class="line">                res[idx] = nums[i%len];</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i%len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="556-下一个更大元素-III-力扣（LeetCode）"><a href="#556-下一个更大元素-III-力扣（LeetCode）" class="headerlink" title="556. 下一个更大元素 III - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/next-greater-element-iii/" target="_blank" rel="noopener">556. 下一个更大元素 III - 力扣（LeetCode）</a></h4><p>题目大意：</p><p>给定一个正整数 n ，找出：由重新排列 n 中存在的每位数字组成，并且其值大于 n的最小整数 。不存在返回 -1 。</p><p>并且要求返回的整数是32 位整数 ，如果答案不是 32 位整数返回 -1 </p><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: n = <span class="number">12</span></span><br><span class="line">输出: <span class="number">21</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: n = <span class="number">21</span></span><br><span class="line">输出: <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>解题思路：</p><p>给的示例比较简单，我们换一个数字</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: 12443322</span></span><br><span class="line"><span class="section">输出: ?</span></span><br></pre></td></tr></table></figure><p>我们先出满足题意的答案，即比该数字大的且最接近他的数字</p><p>13222344</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法学习笔记-单调栈&quot;&gt;&lt;a href=&quot;#算法学习笔记-单调栈&quot; class=&quot;headerlink&quot; title=&quot;算法学习笔记-单调栈&quot;&gt;&lt;/a&gt;算法学习笔记-单调栈&lt;/h1&gt;&lt;p&gt;今天碰到一道题，印象中感觉可以用单调栈做的，但是发现自己一下子想不起来了，所以还是再看看，加深一下印象&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
      <category term="单调栈" scheme="https://Naskete.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的反转操作（一）</title>
    <link href="https://naskete.github.io/2023/02/19/algorithm/java%E4%B8%AD%E7%9A%84%E5%8F%8D%E8%BD%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://naskete.github.io/2023/02/19/algorithm/java%E4%B8%AD%E7%9A%84%E5%8F%8D%E8%BD%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-02-19T13:49:56.000Z</published>
    <updated>2023-07-08T13:54:14.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA中的反转操作（一）——-字符串"><a href="#JAVA中的反转操作（一）——-字符串" class="headerlink" title="JAVA中的反转操作（一）—— 字符串"></a>JAVA中的反转操作（一）—— 字符串</h1><h3 id="转换为char数组"><a href="#转换为char数组" class="headerlink" title="转换为char数组"></a>转换为char数组</h3><a id="more"></a><p>我一般也会选择使用char数组进行操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = arr[l];</span><br><span class="line">            arr[l++] = arr[r];</span><br><span class="line">            arr[r--] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过StringBuilder-StringBuffer的reverse方法"><a href="#通过StringBuilder-StringBuffer的reverse方法" class="headerlink" title="通过StringBuilder/StringBuffer的reverse方法"></a>通过StringBuilder/StringBuffer的reverse方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA中的反转操作（一）——-字符串&quot;&gt;&lt;a href=&quot;#JAVA中的反转操作（一）——-字符串&quot; class=&quot;headerlink&quot; title=&quot;JAVA中的反转操作（一）—— 字符串&quot;&gt;&lt;/a&gt;JAVA中的反转操作（一）—— 字符串&lt;/h1&gt;&lt;h3 id=&quot;转换为char数组&quot;&gt;&lt;a href=&quot;#转换为char数组&quot; class=&quot;headerlink&quot; title=&quot;转换为char数组&quot;&gt;&lt;/a&gt;转换为char数组&lt;/h3&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://Naskete.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://Naskete.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="https://Naskete.github.io/tags/JAVA/"/>
    
  </entry>
  
</feed>
